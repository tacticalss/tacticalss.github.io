<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote File Processor</title>
    
    <style>
        :root {
            --background-color: #0d0d12;
            --card-background: rgba(22, 22, 30, 0.6);
            --border-color: rgba(255, 255, 255, 0.15);
            --text-color: #e0e0e0;
            --text-muted-color: #909090;
            --accent-color: #3b82f6;
            --success-color: #22c55e;
            --error-color: #ef4444;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 2rem;
            overflow: hidden;
        }

        #shader-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        main {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            z-index: 1;
        }

        header {
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .card {
            background-color: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 1.5rem;
            padding: 1.5rem;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .card h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .url-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            color: var(--text-color);
            font-size: 1rem;
        }
        .url-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        .url-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: relative;
            width: 44px;
            height: 24px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 12px;
            transition: background-color 0.3s;
        }
        .slider::before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        input:checked + .slider {
            background-color: var(--accent-color);
        }
        input:checked + .slider::before {
            transform: translateX(20px);
        }

        .action-button {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            border: none;
            background-color: var(--accent-color);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
        }
        .action-button.cancel {
            background-color: var(--error-color);
        }
        .action-button:disabled {
            opacity: 0.5;
            cursor: wait;
        }
        .action-button:not(:disabled):hover {
            opacity: 0.9;
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .status-icon {
            font-size: 1.25rem;
        }
        .status-icon.info { color: var(--accent-color); }
        .status-icon.success { color: var(--success-color); }
        .status-icon.error { color: var(--error-color); }
        .status-icon.upload { color: #a855f7; }

        .progress-container {
            display: flex;
            justify-content: center;
            padding: 1rem 0;
        }
        .progress-ring {
            transform: rotate(-90deg);
        }
        .progress-ring-circle {
            transition: stroke-dashoffset 0.35s;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--text-muted-color);
        }

        #activity-log-list {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .log-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        .log-message {
            font-size: 0.9rem;
        }
        .log-time {
            font-size: 0.75rem;
            color: var(--text-muted-color);
        }
        
        .hidden {
            display: none !important;
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translate(-50%, 200%);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 1.5rem;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 1000;
        }
        #toast.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    </style>
</head>
<body>

    <canvas id="shader-canvas"></canvas>

    <main>
        <header>
            <h1>Remote File Processor</h1>
        </header>

        <div class="card">
            <div class="form-group">
                <input type="text" id="urlInput" class="url-input" placeholder="Enter file URL or paste here" value="http://ipv4.download.thinkbroadband.com/100MB.zip">
                <label for="useProxy" class="toggle-switch">
                    <span>Use Proxy</span>
                    <input type="checkbox" id="useProxy">
                    <span class="slider"></span>
                </label>
                <button id="actionButton" class="action-button">Start Process</button>
            </div>
        </div>

        <div class="card hidden" id="statusCard">
            <div class="status-header">
                <span id="statusIcon" class="status-icon info"></span>
                <span id="statusMessage">Requesting server...</span>
            </div>
            <div class="progress-container">
                <svg class="progress-ring" width="100" height="100">
                    <circle cx="50" cy="50" r="45" stroke="rgba(255,255,255,0.2)" stroke-width="10" fill="transparent"/>
                    <circle id="progressRingCircle" class="progress-ring-circle" cx="50" cy="50" r="45" stroke="var(--accent-color)" stroke-width="10" fill="transparent" stroke-linecap="round"/>
                </svg>
            </div>
            <div class="progress-details">
                <span id="jobPartDetails">Overall Progress</span>
                <span id="percentageText">0%</span>
            </div>
        </div>

        <div class="card hidden" id="activityLogCard">
            <h2>Activity Log</h2>
            <div id="activity-log-list"></div>
        </div>

        <div class="card" id="toast">
            <span id="toastIcon" class="status-icon"></span>
            <span id="toastMessage"></span>
        </div>
    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. CONFIGURATION & STATE ---
            const FLASK_SERVER_IP = "";
            const FLASK_SERVER_URL = `http://${FLASK_SERVER_IP}:5000`;
            const UPLOAD_ENDPOINT = `${FLASK_SERVER_URL}/upload`;
            const STATUS_ENDPOINT = `${FLASK_SERVER_URL}/status`;

            let state = {
                urlInput: "http://ipv4.download.thinkbroadband.com/100MB.zip",
                useProxy: false,
                statusMessage: "Ready to start.",
                progress: 0.0, // 0 to 1
                currentPart: 0,
                totalParts: 0,
                isJobRunning: false,
                isRequesting: false,
                isError: false,
                isSuccess: false,
                activityLog: [],
            };
            let statusTimer = null;

            // --- 2. DOM ELEMENT REFERENCES ---
            const urlInputEl = document.getElementById('urlInput');
            const useProxyEl = document.getElementById('useProxy');
            const actionButtonEl = document.getElementById('actionButton');
            const statusCardEl = document.getElementById('statusCard');
            const statusIconEl = document.getElementById('statusIcon');
            const statusMessageEl = document.getElementById('statusMessage');
            const progressRingEl = document.getElementById('progressRingCircle');
            const jobPartDetailsEl = document.getElementById('jobPartDetails');
            const percentageTextEl = document.getElementById('percentageText');
            const activityLogCardEl = document.getElementById('activityLogCard');
            const activityLogListEl = document.getElementById('activity-log-list');
            const toastEl = document.getElementById('toast');
            const toastIconEl = document.getElementById('toastIcon');
            const toastMessageEl = document.getElementById('toastMessage');

            const radius = progressRingEl.r.baseVal.value;
            const circumference = 2 * Math.PI * radius;
            progressRingEl.style.strokeDasharray = `${circumference} ${circumference}`;
            progressRingEl.style.strokeDashoffset = circumference;
            
            // --- 3. CORE LOGIC (Networking & State Updates) ---

            const ICONS = {
                info: 'ℹ️',
                success: '✅',
                error: '⚠️',
                upload: '⬆️'
            };

            function showToast(message, type = 'info') {
                toastMessageEl.textContent = message;
                toastIconEl.textContent = ICONS[type];
                toastIconEl.className = `status-icon ${type}`;
                toastEl.classList.add('show');
                setTimeout(() => toastEl.classList.remove('show'), 3000);
            }
            
            function addLog(message, type) {
                const log = { id: Date.now(), timestamp: new Date(), message, type };
                state.activityLog = [log, ...state.activityLog.slice(0, 19)];
                updateUI();
            }
            
            function updateStateFromServer(data) {
                state.statusMessage = data.message;
                state.progress = data.progress / 100.0;
                state.currentPart = data.current_file_part || 0;
                state.totalParts = data.total_file_parts || 0;

                const runningStates = ['pending', 'downloading', 'renaming', 'splitting', 'uploading', 'cleaning'];
                state.isJobRunning = runningStates.includes(data.status);
                state.isSuccess = data.status === 'success';
                state.isError = data.status === 'error';

                if (!state.isJobRunning) {
                    stopPolling();
                }
                updateUI();
            }

            async function fetchStatus() {
                try {
                    const response = await fetch(STATUS_ENDPOINT);
                    if (!response.ok) throw new Error("Server not reachable");
                    const data = await response.json();
                    updateStateFromServer(data);
                } catch (error) {
                    state.statusMessage = "Could not connect to server.";
                    state.isError = true;
                    state.isJobRunning = false;
                    stopPolling();
                    updateUI();
                }
            }

            function startPolling() {
                if (statusTimer) return;
                fetchStatus();
                statusTimer = setInterval(fetchStatus, 2000);
            }

            function stopPolling() {
                clearInterval(statusTimer);
                statusTimer = null;
            }

            async function startUpload() {
                state.isRequesting = true;
                state.statusMessage = "Starting job...";
                state.progress = 0;
                state.isError = false;
                state.isSuccess = false;
                updateUI();
                
                try {
                    const response = await fetch(UPLOAD_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Use-Proxy': state.useProxy ? 'true' : 'false'
                        },
                        body: JSON.stringify({ url: state.urlInput })
                    });

                    if (response.status === 202) {
                        showToast("Job started successfully!", 'success');
                        addLog(`Job started for ${state.urlInput}${state.useProxy ? ' (with proxy)' : ''}`, 'upload');
                        startPolling();
                    } else {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'Server returned an error.');
                    }
                } catch (error) {
                    addLog(`Failed to start job: ${error.message}`, 'error');
                    showToast(`Failed to start job: ${error.message}`, 'error');
                    state.isError = true;
                    state.statusMessage = "Failed to start job.";
                } finally {
                    state.isRequesting = false;
                    updateUI();
                }
            }
            
            // --- 4. UI UPDATE LOGIC ---
            function updateUI() {
                const isDisabled = state.isJobRunning || state.isRequesting;
                urlInputEl.disabled = isDisabled;
                useProxyEl.disabled = isDisabled;
                actionButtonEl.disabled = state.isRequesting;

                if (state.isJobRunning) {
                    actionButtonEl.textContent = 'Cancel Job';
                    actionButtonEl.classList.add('cancel');
                    actionButtonEl.disabled = true; // Cancellation not supported by server
                } else {
                    actionButtonEl.textContent = 'Start Process';
                    actionButtonEl.classList.remove('cancel');
                }

                if (state.isJobRunning || state.isSuccess || state.isError) {
                    statusCardEl.classList.remove('hidden');
                } else {
                    statusCardEl.classList.add('hidden');
                }
                
                let statusType = 'info';
                if (state.isSuccess) statusType = 'success';
                if (state.isError) statusType = 'error';

                statusMessageEl.textContent = state.statusMessage;
                statusIconEl.textContent = ICONS[statusType];
                statusIconEl.className = `status-icon ${statusType}`;
                
                const offset = circumference - state.progress * circumference;
                progressRingEl.style.strokeDashoffset = offset;
                progressRingEl.style.stroke = `var(--${statusType}-color)`;
                percentageTextEl.textContent = `${Math.round(state.progress * 100)}%`;

                if (state.totalParts > 1) {
                    jobPartDetailsEl.textContent = `Part ${state.currentPart} of ${state.totalParts}`;
                } else {
                    jobPartDetailsEl.textContent = 'Overall Progress';
                }

                if (state.activityLog.length > 0) {
                    activityLogCardEl.classList.remove('hidden');
                    activityLogListEl.innerHTML = state.activityLog.map(log => `
                        <div class="log-item">
                            <span class="status-icon ${log.type}">${ICONS[log.type]}</span>
                            <div>
                                <div class="log-message">${log.message}</div>
                                <div class="log-time">${log.timestamp.toLocaleTimeString()}</div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    activityLogCardEl.classList.add('hidden');
                }
            }

            // --- 5. EVENT LISTENERS ---
            urlInputEl.addEventListener('input', e => { state.urlInput = e.target.value; });
            useProxyEl.addEventListener('change', e => { state.useProxy = e.target.checked; });
            actionButtonEl.addEventListener('click', () => {
                if (!state.isJobRunning) startUpload();
            });
            
            // --- 6. SHADER BACKGROUND (WebGL) ---
            const canvas = document.getElementById('shader-canvas');
            const gl = canvas.getContext('webgl');
            if (gl) {
                const vertexShaderSource = `attribute vec2 a_position; void main() { gl_Position = vec4(a_position, 0.0, 1.0); }`;
                const fragmentShaderSource = `
                    precision mediump float;
                    uniform vec2 u_resolution;
                    uniform float u_time;

                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st);
                        vec2 f = fract(st);
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }

                    void main() {
                        vec2 st = gl_FragCoord.xy / u_resolution.xy;
                        st.x *= u_resolution.x / u_resolution.y;
                        float n = noise(st * 4.0 + u_time * 0.05);
                        gl_FragColor = vec4(n * 0.05, n * 0.1, n * 0.2, 1.0);
                    }
                `;

                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vertexShaderSource);
                gl.compileShader(vs);

                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fragmentShaderSource);
                gl.compileShader(fs);

                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                gl.useProgram(program);

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(program, "a_position");
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                const timeLocation = gl.getUniformLocation(program, "u_time");

                function resize() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                }
                window.addEventListener('resize', resize);
                resize();
                
                function animate(time) {
                    gl.uniform1f(timeLocation, time * 0.001);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    requestAnimationFrame(animate);
                }
                animate(0);
            }

            // --- 7. INITIALIZE ---
            fetchStatus(); // Initial status check on load
            updateUI(); // Set initial UI state
        });
    </script>
</body>
</html>
